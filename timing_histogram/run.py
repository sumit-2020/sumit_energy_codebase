#!/usr/bin/python

import sys, os, subprocess as sp, glob
import tarfile, zipfile
import argparse
import operator
import time

# Global parameters across the tests
patterns = ["0xaa","0xff","0xcc"]
votes = {"t_rcd" : 0 , "t_rp" : 0 , "no_idea" : 0}
FNULL = open(os.devnull, 'w')
up_limit = [8,8]
FAIL_IN_ARGUMENTS 	= -1
COMPLETE_SUCCESS  	= 0
LOW_TRCD 			= 248 
LOW_TRP 			= 249
NO_IDEA 			= 250 
FPGA_NOT_FOUND 		= 251
FPGA_NOT_ACCESSIBLE = 252
MAX_NUM_OF_ATTEMPTS = 3 

# Pair list is generated by another Python script. Contact: @giray
# pair_list = [(3,3), (3,4), (4,3), (3,5), (4,4), (5,3), (3,6), (4,5), (5,4), (6,3), (3,7), (4,6), (5,5), (6,4), (7,3), (3,8), (4,7), (5,6), (6,5), (7,4), (8,3), (3,9), (4,8), (5,7), (6,6), (7,5), (8,4), (9,3), (3,10), (4,9), (5,8), (6,7), (7,6), (8,5), (9,4), (10,3), (3,11), (4,10), (5,9), (6,8), (7,7), (8,6), (9,5), (10,4), (11,3), (3,12), (4,11), (5,10), (6,9), (7,8), (8,7), (9,6), (10,5), (11,4), (12,3), (3,13), (4,12), (5,11), (6,10), (7,9), (8,8), (9,7), (10,6), (11,5), (12,4), (13,3) ]

# 										      (3,3)										
# 									      (3,4)   (4,3)									
# 								      (3,5)   (4,4)   (5,3)								
# 							      (3,6)   (4,5)	  (5,4)   (6,3)							
# 						      (3,7)   (4,6)	  (5,5)	  (6,4)   (7,3)						
# 					      (3,8)   (4,7)	  (5,6)	  (6,5)	  (7,4)	  (8,3)					
# 				      (3,9)   (4,8)	  (5,7)	  (6,6)	  (7,5)  | (8,4)   (9,3)				
# 			     (3,10)   (4,9)	  (5,8)   (6,7)	  (7,6)	  (8,5)   (9,4)   (10,3)			
# 		    (3,11)    (4,10)  (5,9)	  (6,8)	  (7,7)	  (8,6)   (9,5)	  (10,4)   (11,3)		
#      (3,12)    (4,11)	  (5,10)  (6,9)   (7,8)	  (8,7)	  (9,6)   (10,5)   (11,4)	(12,3)	
# (3,13)    (4,12)   (5,11)   (6,10)  (7,9)	  (8,8)	  (9,7)	  (10,6)   (11,5)	(12,4)	 (13,3)


# 										      (3,3)										
# 									      (3,4)   (4,3)									
# 								      (3,5)   (3,6) (4,4)   							
# 							         (4,5)	  (5,4)   							
# 						     <-| (5,5)  |-> (4,6)	 (5,6) 	    					
# 					       (6,4) (4,7)	  	 (6,5)	  (7,4)	  				
# 				         (4,8)	  (5,7)	  (6,6)	  (7,5) 

# Start from 5,5
# Pass, keep going left until 1 fails. 
# Fail, keep going right until 1 passes.

pair_list = [(3,3), (3,4), (4,3), (3,5), (3,6), (4,4), (4,5), (5,4), (5,5), (4,6), (5,6), (6,4), (4,7), (6,5), (7,4), (4,8), (5,7), (6,6), (7,5)]

def find_initial_in_list(init_trcd,init_trp,pair_list):
	for i,p in enumerate(pair_list):
		if p[0] == init_trcd and p[1] == init_trp :
			return i
	return -1

def get_half_list(init_trcd,init_trp,pair_list,direction) :
	init_index = find_initial_in_list(init_trcd,init_trp,pair_list)
	if init_index == -1 :
		print "Given initial tRCD and tRP values are not in the range. Put one of the following values"
		print pair_list
		exit()

	ret_list = []

	if direction == -1 :
		if init_index > 1 :
			for i in reversed(range(init_index)) :
				ret_list.append(pair_list[i])
	elif direction == 1 :
		if init_index < len(pair_list) - 1 :
			for i in range(init_index+1,len(pair_list)) :
				ret_list.append(pair_list[i])

	return ret_list

# @brief Creates the shell command for one particular test, and runs the test
# once this process is done, the log file is supposed to be created in the same
# directory. It moves the log file to corresponding directory.
def run_binary(args,patt,t_rcd,t_rp):
	shell_command  = "./bin/safari_mc_test "
	shell_command += args.dimm + " " + patt + " "
	shell_command += str(t_rcd) + " " + str(t_rp) + " "
	shell_command += str(args.iter) + " " + str(args.temp) + " " + str(args.vdd)

	print "'"+shell_command + "' "
	start_binary = time.time()
	ret_val = sp.call(shell_command, shell=True, stdout=FNULL)
	stop_binary = time.time()
	print "(" + '{0:.2f}'.format(stop_binary - start_binary) + " s.) ",

	sp.call("../drain_buffers/bin/safari_mc_test", shell=True, stdout=FNULL)
	sp.call("../drain_buffers/bin/safari_mc_test", shell=True, stdout=FNULL)
	
	return ret_val

# @brief finds the most current log file with the given conditions
def find_log_file(args,t_rcd,t_rp):
	file_name  = "out/"
	file_name += args.dimm
	file_name += "_rcd" + str(t_rcd)
	file_name += "_rp" + str(t_rp)
	file_name += "_ret0"
	file_name += "_temp" + str(args.temp)
	file_name += "_volt" + "{:1.6f}".format(args.vdd)
	file_name += "*.hist"
	print "File name should be: " + file_name

	newest_file = max(glob.iglob(file_name), key=os.path.getctime)
	print "Matching file: " + newest_file

	return newest_file

# @brief The error bits are matched here and new timing values are set
def analyze_the_file(file_name):
	print "Log file is being analyzed here"


# @brief Archieve the log file and remove to save some space.
def archieve_the_file(file_name, zipfile_name):
	archieve = zipfile.ZipFile(zipfile_name, "w" )
	archieve.write(file_name, compress_type=zipfile.ZIP_DEFLATED)
	archieve.close()
	os.remove(file_name)


def clear_and_compile():
	sp.call("clear")
	#print 'Cleaning the previous histogram files'
	#sp.call("rm out/*.hist", shell=True, stdout=FNULL)
	print 'Building the binary again'
	sp.call("make all", shell=True, stdout=FNULL, stderr=sp.STDOUT)

# @brief The given DIMM is supplied with [vdd] volts in [temp]C environment.
# The procedure runs the combined timing test to measure the minimum t_rcd and t_rd
# values under the given circumstances. The main procedure starts with a small initial
# value for both parameters. Each parameter is increased based on the pattern of the
# error bit vector.
def main():
	clear_and_compile()
	print 'Finding the minimum t_rcd and t_rp values'
	print 'Arguments are being parsed'
	parser = argparse.ArgumentParser()
	parser.add_argument('dimm', metavar='dimm'	, type=str 		, default='DIMM_NAME' 	, help='DIMM Name'						)
	parser.add_argument('init', metavar='init'	, type=int  	, default=5				, help='Initial t_rc and t_rp values'	)
	parser.add_argument('iter', metavar='iter'	, type=int 		, default=1				, help='# of iterations'				)
	parser.add_argument('temp', metavar='temp'	, type=int 		, default=20 			, help='Temperature'					)
	parser.add_argument('vdd' , metavar='vdd'	, type=float 	, default=1.5			, help='VDD'							)
	args = parser.parse_args()

	zipfile_name = args.dimm + '_' + str(args.temp) + '_' + str(args.vdd) + '.zip'

	# The initial values of t_rcd and t_rp are set here.
	latencies   = [args.init, args.init] # [ t_rcd , t_rp ] 

	tuner_start = time.time()
	print "=========================================="
	print "Exp 1 is starting with: (tRCD,tRP) = (" + str(latencies[0]) + " , " + str(latencies[1]) + ")"
	success = 0
	exp_start = time.time()
	for patt in patterns :
		flag = True
		while (flag) :
			ret_val = run_binary(args,patt,latencies[0],latencies[1])
			print "ret_val: " + str(ret_val)
			if ret_val in [COMPLETE_SUCCESS , LOW_TRCD, LOW_TRP, NO_IDEA] :
				flag = False
			if ret_val == COMPLETE_SUCCESS :
				success += 1
	exp_stop = time.time()
	print "Exp finished in " '{0:.2f}'.format((exp_stop - exp_start) / 60) + " mins. "

	if success == 3: 
		direction = -1
	else :
		direction = 1

	half_list 	= get_half_list(latencies[0],latencies[1],pair_list,direction) 

	print ""
	print half_list

	for i,p in enumerate(half_list) :
		
		print "=========================================="
		print "Exp "+str(i+2)+" is starting with: (tRCD,tRP) = (" + str(p[0]) + " , " + str(p[1]) + ")"
		success = 0

		exp_start = time.time()
		for patt in patterns :
			flag = True
			num_of_attempts = 0
			while (flag) :
				ret_val = run_binary(args,patt,p[0],p[1])
				num_of_attempts = num_of_attempts + 1
				print " attempt #"+str(num_of_attempts)+" ret_val: " + str(ret_val)
				
				if ret_val in [COMPLETE_SUCCESS , LOW_TRCD, LOW_TRP, NO_IDEA] :
					flag = False

				else :
					if (num_of_attempts == MAX_NUM_OF_ATTEMPTS) :
						print "max # of attempts is reached for the failure. Please fix the error messages above and restart the whole system"
						exit()

				if ret_val == COMPLETE_SUCCESS :
					success += 1
		exp_stop = time.time()
		print "Exp finished in " '{0:.2f}'.format((exp_stop - exp_start) / 60) + " mins. "

		if direction == 1 and success == 3:
			print "Min (tRCD,tRP) = ",
			print p
			break

		elif direction == -1 and success != 3:
			print "Min (tRCD,tRP) = ",
			if i > 0 :
				print half_list[i-1]
			else :
				print latencies
			break

		
	tuner_stop = time.time()
	print "Min Latency values are found in " '{0:.2f}'.format((tuner_stop - tuner_start) / 60) + " mins. "

main() 
FNULL.close()

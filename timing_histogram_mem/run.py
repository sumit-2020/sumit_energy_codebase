#!/usr/bin/python

import sys, os, subprocess as sp, glob
import tarfile, zipfile
import argparse
import operator
import time

# Global parameters across the tests
patterns = ["0xaa","0xff","0xcc"]
votes = {"t_rcd" : 0 , "t_rp" : 0 , "no_idea" : 0}
FNULL = open(os.devnull, 'w')
up_limit = [8,8]
FAIL_IN_ARGUMENTS 	= -1
COMPLETE_SUCCESS  	= 0
LOW_TRCD 			= 248
LOW_TRP 			= 249
NO_IDEA 			= 250
FPGA_NOT_FOUND 		= 251
FPGA_NOT_ACCESSIBLE = 252
MAX_NUM_OF_ATTEMPTS = 3

# Pair list is generated by another Python script. Contact: @giray
# pair_list = [(3,3), (3,4), (4,3), (3,5), (4,4), (5,3), (3,6), (4,5), (5,4), (6,3), (3,7), (4,6), (5,5), (6,4), (7,3), (3,8), (4,7), (5,6), (6,5), (7,4), (8,3), (3,9), (4,8), (5,7), (6,6), (7,5), (8,4), (9,3), (3,10), (4,9), (5,8), (6,7), (7,6), (8,5), (9,4), (10,3), (3,11), (4,10), (5,9), (6,8), (7,7), (8,6), (9,5), (10,4), (11,3), (3,12), (4,11), (5,10), (6,9), (7,8), (8,7), (9,6), (10,5), (11,4), (12,3), (3,13), (4,12), (5,11), (6,10), (7,9), (8,8), (9,7), (10,6), (11,5), (12,4), (13,3) ]

# 										      (3,3)
# 									      (3,4)   (4,3)
# 								      (3,5)   (4,4)   (5,3)
# 							      (3,6)   (4,5)	  (5,4)   (6,3)
# 						      (3,7)   (4,6)	  (5,5)	  (6,4)   (7,3)
# 					      (3,8)   (4,7)	  (5,6)	  (6,5)	  (7,4)	  (8,3)
# 				      (3,9)   (4,8)	  (5,7)	  (6,6)	  (7,5)  | (8,4)   (9,3)
# 			     (3,10)   (4,9)	  (5,8)   (6,7)	  (7,6)	  (8,5)   (9,4)   (10,3)
# 		    (3,11)    (4,10)  (5,9)	  (6,8)	  (7,7)	  (8,6)   (9,5)	  (10,4)   (11,3)
#      (3,12)    (4,11)	  (5,10)  (6,9)   (7,8)	  (8,7)	  (9,6)   (10,5)   (11,4)	(12,3)
# (3,13)    (4,12)   (5,11)   (6,10)  (7,9)	  (8,8)	  (9,7)	  (10,6)   (11,5)	(12,4)	 (13,3)


# 										      (3,3)
# 									      (3,4)   (4,3)
# 								      (3,5)   (3,6) (4,4)
# 							         (4,5)	  (5,4)
# 						     <-| (5,5)  |-> (4,6)	 (5,6)
# 					       (6,4) (4,7)	  	 (6,5)	  (7,4)
# 				         (4,8)	  (5,7)	  (6,6)	  (7,5)

# Start from 5,5
# Pass, keep going left until 1 fails.
# Fail, keep going right until 1 passes.

#pair_list = [(3,3), (3,4), (4,3), (3,5), (3,6), (4,4), (4,5), (5,4), (5,5), (4,6), (5,6), (6,4), (4,7), (6,5), (7,4), (4,8), (5,7), (6,6), (7,5)]

# Cut down on finding the higher latency
pair_list = [(3,3), (3,4), (4,3), (3,5), (3,6), (4,4), (4,5), (5,4), (5,5), (8,8)]

def find_initial_in_list(init_trcd,init_trp,pair_list):
    for i,p in enumerate(pair_list):
        if p[0] == init_trcd and p[1] == init_trp :
            return i
    return -1

def get_half_list(init_trcd,init_trp,pair_list,direction) :
    init_index = find_initial_in_list(init_trcd,init_trp,pair_list)
    if init_index == -1 :
        print "Given initial tRCD and tRP values are not in the range. Put one of the following values"
        print pair_list
        exit()

    ret_list = []

    if direction == -1 :
        if init_index > 1 :
            for i in reversed(range(init_index)) :
                ret_list.append(pair_list[i])
    elif direction == 1 :
        if init_index < len(pair_list) - 1 :
            for i in range(init_index+1,len(pair_list)) :
                ret_list.append(pair_list[i])

    return ret_list

# @brief Creates the shell command for one particular test, and runs the test
# once this process is done, the log file is supposed to be created in the same
# directory. It moves the log file to corresponding directory.
def run_binary(args,patt,t_rcd,t_rp):
    shell_command  = "./bin/safari_mc_test "
    shell_command += args.dimm + " " + patt + " "
    shell_command += str(t_rcd) + " " + str(t_rp) + " "
    shell_command += str(args.iter) + " " + str(args.temp) + " " + str(args.vdd)

    print "'"+shell_command + "' "
    start_binary = time.time()
    ret_val = sp.call(shell_command, shell=True, stdout=FNULL)
    stop_binary = time.time()
    print "(" + '{0:.2f}'.format(stop_binary - start_binary) + " s.) ",

    sp.call("../drain_buffers/bin/safari_mc_test", shell=True, stdout=FNULL)
    sp.call("../drain_buffers/bin/safari_mc_test", shell=True, stdout=FNULL)

    return ret_val

# @brief finds the most current log file with the given conditions
def find_log_file(args,t_rcd,t_rp):
    file_name  = "out/"
    file_name += args.dimm
    file_name += "_rcd" + str(t_rcd)
    file_name += "_rp" + str(t_rp)
    file_name += "_ret0"
    file_name += "_temp" + str(args.temp)
    file_name += "_volt" + "{:1.6f}".format(args.vdd)
    file_name += "*.hist"
    print "File name should be: " + file_name

    newest_file = max(glob.iglob(file_name), key=os.path.getctime)
    print "Matching file: " + newest_file

    return newest_file

# @brief The error bits are matched here and new timing values are set
def analyze_the_file(file_name):
    print "Log file is being analyzed here"


# @brief Archieve the log file and remove to save some space.
def archieve_the_file(file_name, zipfile_name):
    archieve = zipfile.ZipFile(zipfile_name, "w" )
    archieve.write(file_name, compress_type=zipfile.ZIP_DEFLATED)
    archieve.close()
    os.remove(file_name)


def clear_and_compile():
    sp.call("clear")
    #print 'Cleaning the previous histogram files'
    #sp.call("rm out/*.hist", shell=True, stdout=FNULL)
    print 'Building the binary again'
    sp.call("make all", shell=True, stdout=FNULL, stderr=sp.STDOUT)

# @brief The given DIMM is supplied with [vdd] volts in [temp]C environment.
# The procedure runs the combined timing test to measure the minimum t_rcd and t_rd
# values under the given circumstances. The main procedure starts with a small initial
# value for both parameters. Each parameter is increased based on the pattern of the
# error bit vector.
def main():
    clear_and_compile()
    print 'Finding the minimum t_rcd and t_rp values'
    print 'Arguments are being parsed'
    parser = argparse.ArgumentParser()
    parser.add_argument('dimm', metavar='dimm'	, type=str 		, default='DIMM_NAME' 	, help='DIMM Name'						)
    parser.add_argument('init', metavar='init'	, type=int  	, default=5				, help='Initial t_rc and t_rp values'	)
    parser.add_argument('iter', metavar='iter'	, type=int 		, default=1				, help='# of iterations'				)
    parser.add_argument('temp', metavar='temp'	, type=int 		, default=20 			, help='Temperature'					)
    parser.add_argument('vdd' , metavar='vdd'	, type=float 	, default=1.5			, help='VDD'							)
    parser.add_argument('--rp', metavar='rp'	, type=int  	, default=-1,
            help='Initial t_rp value. If supplied, init is tRCD implicitly.'	)
    parser.add_argument('--one', action='store_true'  	, default=False, help='Test one pair of latencies without stepping.'	)
    args = parser.parse_args()

    zipfile_name = args.dimm + '_' + str(args.temp) + '_' + str(args.vdd) + '.zip'

    # The initial values of t_rcd and t_rp are set here.
    latencies = []
    if args.rp == -1:
        latencies   = [args.init, args.init] # [ t_rcd , t_rp ]
    else:
        latencies   = [args.init, args.rp] # [ t_rcd , t_rp ]

    tuner_start = time.time()
    print "=========================================="
    print "Exp 1 is starting with: (tRCD,tRP) = (" + str(latencies[0]) + " , " + str(latencies[1]) + ")"
    success = 0
    exp_start = time.time()
    for patt in patterns :
        flag = True
        num_of_attempts = 0
        while (flag) :
            ret_val = run_binary(args,patt,latencies[0],latencies[1])
            num_of_attempts = num_of_attempts + 1
            print "ret_val: " + str(ret_val)
            if ret_val in [COMPLETE_SUCCESS , LOW_TRCD, LOW_TRP, NO_IDEA] :
                flag = False
            else :
                if (num_of_attempts == MAX_NUM_OF_ATTEMPTS) :
                    print "max # of attempts is reached for the failure. Please fix the error messages above and restart the whole system"
                    exit()
            if ret_val == COMPLETE_SUCCESS :
                success += 1
    exp_stop = time.time()
    print "Exp finished in " '{0:.2f}'.format((exp_stop - exp_start) / 60) + " mins. "

    # Test only one lateny pair
    if args.one:
        sys.exit()

    if success == 3:
        direction = -1
    else :
        direction = 1

    half_list 	= get_half_list(latencies[0],latencies[1],pair_list,direction)

    print ""
    print half_list

    for i,p in enumerate(half_list) :

        print "=========================================="
        print "Exp "+str(i+2)+" is starting with: (tRCD,tRP) = (" + str(p[0]) + " , " + str(p[1]) + ")"
        success = 0

        exp_start = time.time()
        for patt in patterns :
            flag = True
            num_of_attempts = 0
            while (flag) :
                ret_val = run_binary(args,patt,p[0],p[1])
                num_of_attempts = num_of_attempts + 1
                print " attempt #"+str(num_of_attempts)+" ret_val: " + str(ret_val)

                if ret_val in [COMPLETE_SUCCESS , LOW_TRCD, LOW_TRP, NO_IDEA] :
                    flag = False
                else :
                    if (num_of_attempts == MAX_NUM_OF_ATTEMPTS) :
                        print "max # of attempts is reached for the failure. Please fix the error messages above and restart the whole system"
                        exit()
                if ret_val == COMPLETE_SUCCESS :
                    success += 1
        exp_stop = time.time()
        print "Exp finished in " '{0:.2f}'.format((exp_stop - exp_start) / 60) + " mins. "

        if direction == 1 and success == 3:
            print "Min (tRCD,tRP) = ",
            print p
            break

        elif direction == -1 and success != 3:
            print "Min (tRCD,tRP) = ",
            if i > 0 :
                print half_list[i-1]
            else :
                print latencies
            break


    tuner_stop = time.time()
    print "Min Latency values are found in " '{0:.2f}'.format((tuner_stop - tuner_start) / 60) + " mins. "

main()
FNULL.close()
